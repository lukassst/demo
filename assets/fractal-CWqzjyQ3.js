import{a as G}from"./index-Br1290MD.js";function C(t,o,e,r,l,f,i="clamp",a="nearest"){const n=l>1?o/l:o/2,s=f>1?e/f:e/2,c=a==="nearest"||a==="nearestNeighbor";for(let d=0;d<f;d++)for(let m=0;m<l;m++){const u=(m+.5)*n-.5,p=(d+.5)*s-.5;let w;if(c){const y=Math.round(u),M=Math.round(p);w=E(t,y,M,o,e,i)}else{const y=Math.floor(u),M=Math.floor(p),h=E(t,y,M,o,e,i),A=E(t,y+1,M,o,e,i),v=E(t,y,M+1,o,e,i),z=E(t,y+1,M+1,o,e,i),b=u-y,F=p-M;w=(1-b)*(1-F)*h+b*(1-F)*A+(1-b)*F*v+b*F*z}r[m+d*l]=w}}function E(t,o,e,r,l,f){if(o>=0&&o<r&&e>=0&&e<l)return t[o+e*r];let i=o,a=e;switch(f){case"clamp":i=Math.max(0,Math.min(r-1,o)),a=Math.max(0,Math.min(l-1,e));break;case"mirror":o<0?i=-o-1:o>=r&&(i=2*r-o-1),e<0?a=-e-1:e>=l&&(a=2*l-e-1),i=Math.max(0,Math.min(r-1,i)),a=Math.max(0,Math.min(l-1,a));break;case"wrap":i=(o%r+r)%r,a=(e%l+l)%l;break;case"zero":return 0;default:i=Math.max(0,Math.min(r-1,o)),a=Math.max(0,Math.min(l-1,e))}return t[i+a*r]}async function P(t,o){if(o<=0)throw new Error("Resolution must be positive");const[e,r,l]=t.size,f=t.spacing,i=t.data,a=Math.max(1,Math.round(e*f[0]/o)),n=Math.max(1,Math.round(r*f[1]/o)),s=e*r,c=a*n,d={imageType:{dimension:t.imageType.dimension,componentType:"float32",pixelType:t.imageType.pixelType,components:t.imageType.components},name:"ResampledImage",origin:[...t.origin],spacing:[o,o,f[2]],direction:new Float64Array(t.direction),size:[a,n,l],data:new Float32Array(c*l)},m=new Float32Array(c);for(let u=0;u<l;u++){const p=u*s,w=i.subarray(p,p+s),y=u*c;m.fill(0),C(w,e,r,m,a,n),d.data.set(m,y)}return d}async function X(t,o,e,r={}){const{windowSize:l=7,scales:f=[1,2,3],method:i=0,backend:a="webgl"}=r;performance.now();let n;switch(i){case 1:n=await J(t,o,e,r);break;case 2:n=await Q(t,o,e,r);break;case 0:default:n=await K(t,o,e,r);break}return performance.now(),n}async function K(t,o,e,r={}){await G();const{windowSize:l=7,scales:f=[1,2,3],backend:i="webgl"}=r;return tf.setBackend(i),tf.tidy(()=>{const a=tf.tensor2d(t,[e,o],"float32");if(a.rank!==2)throw new Error("Input image must be 2D.");const n=a.expandDims(0).expandDims(-1),s=f[f.length-1],c=tf.log(tf.tensor1d(f,"float32")),d={},m={};let u=n.clone(),p=n.clone();d[0]=u.clone(),m[0]=p.clone(),tf.ones([3,3,1],"bool");const w=3,y=1,M="valid",h=[[0,0],[1,1],[1,1],[0,0]];for(let T=1;T<=s;T++){const D=u,S=p;u=tf.tidy(()=>{const L=tf.pad(D,h,"reflect"),U=tf.maxPool(L,w,y,M);return tf.maximum(tf.add(D,1),U)}),p=tf.tidy(()=>{const L=S.neg(),U=tf.pad(L,h,"reflect"),O=tf.maxPool(U,w,y,M).neg();return tf.minimum(tf.sub(S,1),O)}),tf.dispose([D,S]),f.includes(T)&&(d[T]=u.clone(),m[T]=p.clone())}f.includes(s)||tf.dispose([u,p]);const A=[],v=tf.scalar(l*l,"float32"),z=tf.scalar(1e-6);for(const T of f){const D=tf.sub(d[T],m[T]),S=tf.avgPool(D,l,1,"same"),L=tf.mul(S,v),U=tf.maximum(L.squeeze([0,3]),z);A.push(tf.log(U)),tf.dispose([D,S,L,U,d[T],m[T]])}tf.dispose([d[0],m[0]]);const b=tf.stack(A,0),F=c.reshape([-1,1,1]),x=tf.tile(F,[1,e,o]),g=nt(x,b),k=tf.sub(3,g),B=k.clipByValue(2,3);tf.dispose(A),tf.dispose([b,F,x,g,k]);const I=B.dataSync();return tf.dispose([a,B,...Object.values(d),...Object.values(m)].filter(Boolean)),new Float32Array(I)})}async function lt(t,o,e,r,l,f,i,a){const s=2*(3-t)+2,c=Z(o,o,s),d=await X(c,o,o,{windowSize:e,scales:l,method:i}),m=await X(c,o,o,{windowSize:r,scales:f,method:a});return{originalImage:c,fractalDimension1:d,fractalDimension2:m,parameters:{dimension:t,size:o,window1:e,window2:r,scales1:l,scales2:f,method1:i,method2:a}}}async function J(t,o,e,r={}){const{windowSize:l=7,scales:f=[1,2,3]}=r,i=Math.floor(l/2),a=new Float32Array(o*e),n=[],s=[];n[0]=new Float32Array(t),s[0]=new Float32Array(t);for(let c=1;c<=f[f.length-1];c++){n[c]=new Float32Array(o*e),s[c]=new Float32Array(o*e);for(let d=0;d<e;d++)for(let m=0;m<o;m++){const u=d*o+m;let p=n[c-1][u]+1,w=s[c-1][u]-1;for(let y=-1;y<=1;y++)for(let M=-1;M<=1;M++){const h=Math.min(Math.max(d+y,0),e-1),A=Math.min(Math.max(m+M,0),o-1),v=h*o+A;p=Math.max(p,n[c-1][v]),w=Math.min(w,s[c-1][v])}n[c][u]=p,s[c][u]=w}}for(let c=0;c<e;c++)for(let d=0;d<o;d++){const m=[],u=[];for(let M of f){let h=0;for(let A=-i;A<=i;A++)for(let v=-i;v<=i;v++){const z=Math.min(Math.max(c+A,0),e-1),b=Math.min(Math.max(d+v,0),o-1),F=z*o+b;h+=n[M][F]-s[M][F]}h>0&&(m.push(Math.log(h)),u.push(Math.log(M)))}const{slope:p}=q(u,m),w=3-p,y=c*o+d;a[y]=Math.min(3,Math.max(2,w))}return a}function q(t,o){if(!Array.isArray(t)||!Array.isArray(o)||t.length!==o.length||t.length===0)return{slope:0,intercept:0};const e=t.length;let r=0,l=0,f=0,i=0;for(let c=0;c<e;c++){if(typeof t[c]!="number"||typeof o[c]!="number"||!isFinite(t[c])||!isFinite(o[c]))return{slope:0,intercept:0};r+=t[c],l+=o[c],f+=t[c]*o[c],i+=t[c]*t[c]}const a=e*i-r*r;if(a===0)return{slope:0,intercept:l/e};const n=(e*f-r*l)/a,s=(l-n*r)/e;return{slope:n,intercept:s}}async function Q(t,o,e,r={}){const{windowSize:l=7,scales:f=[1,2,3]}=r,i=new Float32Array(o*e),a=Math.floor(l/2);for(let n=0;n<e;n++)for(let s=0;s<o;s++){const c=new Float32Array(l*l);for(let A=0;A<l;A++)for(let v=0;v<l;v++){const z=n+A-a,b=s+v-a,F=Math.max(0,Math.min(e-1,z)),x=Math.max(0,Math.min(o-1,b));c[A*l+v]=t[F*o+x]}let d=new Float32Array(c),m=new Float32Array(c);const u=[],p=Math.max(...f);for(let A=1;A<=p;A++){const v=d,z=m;d=new Float32Array(l*l),m=new Float32Array(l*l);for(let b=0;b<l;b++)for(let F=0;F<l;F++){const x=b*l+F;let g=v[x]+1,k=z[x]-1;for(let B=-1;B<=1;B++)for(let I=-1;I<=1;I++){const T=b+B,D=F+I;if(T>=0&&T<l&&D>=0&&D<l){const S=T*l+D;g=Math.max(g,v[S]),k=Math.min(k,z[S])}}d[x]=g,m[x]=k}if(f.includes(A)){let b=0;for(let F=0;F<d.length;F++)b+=d[F]-m[F];u.push(b>0?b:1e-9)}}if(u.length!==f.length){i[n*o+s]=2;continue}const w=u.map(A=>Math.log(A)),y=f.map(A=>Math.log(A));if(y.length<2){i[n*o+s]=2;continue}const{slope:M}=q(y,w),h=3-M;i[n*o+s]=Math.min(3,Math.max(2,h))}return i}function Z(t,o,e){console.time("fBm Generation");const r=new Float32Array(t*o),l=new Float32Array(t*o);for(let s=0;s<o;s++)for(let c=0;c<t;c++){const d=c<t/2?c:c-t,m=s<o/2?s:s-o,u=Math.sqrt(d*d+m*m),p=s*t+c;if(u===0)r[p]=0,l[p]=0;else{const w=Math.pow(u,-e/2),y=Math.random()*2*Math.PI;r[p]=w*Math.cos(y),l[p]=w*Math.sin(y)}}W(r,l,!0,t,o);const f=new Float32Array(t*o);for(let s=0;s<t*o;s++)f[s]=r[s];let i=1/0,a=-1/0;for(let s=0;s<f.length;s++)f[s]<i&&(i=f[s]),f[s]>a&&(a=f[s]);const n=new Uint8ClampedArray(t*o);for(let s=0;s<f.length;s++)n[s]=Math.round((f[s]-i)/(a-i)*255);return console.timeEnd("fBm Generation"),n}function W(t,o,e=!1,r,l){for(let a=0;a<l;a++){const n=new Float32Array(r),s=new Float32Array(r);for(let c=0;c<r;c++){const d=a*r+c;n[c]=t[d],s[c]=o[d]}e?$(n,s):j(n,s);for(let c=0;c<r;c++){const d=a*r+c;t[d]=n[c],o[d]=s[c]}}const f=new Float32Array(r*l),i=new Float32Array(r*l);for(let a=0;a<l;a++)for(let n=0;n<r;n++)f[n*l+a]=t[a*r+n],i[n*l+a]=o[a*r+n];for(let a=0;a<r;a++){const n=new Float32Array(l),s=new Float32Array(l);for(let c=0;c<l;c++){const d=a*l+c;n[c]=f[d],s[c]=i[d]}e?$(n,s):j(n,s);for(let c=0;c<l;c++){const d=a*l+c;f[d]=n[c],i[d]=s[c]}}for(let a=0;a<l;a++)for(let n=0;n<r;n++)t[a*r+n]=f[n*l+a],o[a*r+n]=i[n*l+a]}function V(t,o,e){return(t*73856093^o*19349663^e*83492791)%1e6/1e6}function H(t,o,e){const r=Math.floor(t),l=Math.floor(o),f=Math.floor(e),i=r+1,a=l+1,n=f+1,s=t-r,c=o-l,d=e-f,m=V(r,l,f),u=V(i,l,f),p=V(r,a,f),w=V(i,a,f),y=V(r,l,n),M=V(i,l,n),h=V(r,a,n),A=V(i,a,n),v=m*(1-s)+u*s,z=p*(1-s)+w*s,b=y*(1-s)+M*s,F=h*(1-s)+A*s,x=v*(1-c)+z*c,g=b*(1-c)+F*c;return x*(1-d)+g*d}function tt(t,o,e,r,l,f){let i=0,a=1,n=1;for(let s=0;s<l;s++)i+=a*H(t*n*r,o*n*r,e*n*r),a*=f,n*=2;return i}function ot(t,o){const e=t.length;if(e!==o.length||(e&e-1)!==0)throw new Error("Invalid array length: must be power of 2");let r=-1;for(let n=0;n<32;n++)1<<n===e&&(r=n);if(r===-1)throw new Error("Length is not a power of 2");const l=new Float32Array(e/2),f=new Float32Array(e/2);for(let n=0;n<e/2;n++)l[n]=Math.cos(2*Math.PI*n/e),f[n]=Math.sin(2*Math.PI*n/e);function i(n,s){let c=0;for(let d=0;d<s;d++)c=c<<1|n&1,n>>>=1;return c}const a=e;for(let n=0;n<a;n++){const s=i(n,r);if(s>n){const c=t[n];t[n]=t[s],t[s]=c;const d=o[n];o[n]=o[s],o[s]=d}}for(let n=2;n<=e;n*=2){const s=n/2,c=e/n;for(let d=0;d<e;d+=n)for(let m=d,u=0;m<d+s;m++,u+=c){const p=t[m+s]*l[u]+o[m+s]*f[u],w=-t[m+s]*f[u]+o[m+s]*l[u];t[m+s]=t[m]-p,o[m+s]=o[m]-w,t[m]+=p,o[m]+=w}}}function j(t,o){const e=t.length;if(e!==o.length)throw new Error("Mismatched lengths");if((e&e-1)===0)ot(t,o);else{const r=new Float32Array(e*e),l=new Float32Array(e*e);for(let a=0;a<e;a++)for(let n=0;n<e;n++){const s=-2*Math.PI*(a*n%e)/e;r[a*e+n]=Math.cos(s),l[a*e+n]=Math.sin(s)}const f=new Float32Array(e),i=new Float32Array(e);for(let a=0;a<e;a++){let n=0,s=0;for(let c=0;c<e;c++)n+=t[c]*r[c*e+a]+o[c]*l[c*e+a],s+=-t[c]*l[c*e+a]+o[c]*r[c*e+a];f[a]=n,i[a]=s}for(let a=0;a<e;a++)t[a]=f[a],o[a]=i[a]}}function $(t,o){const e=t.length;for(let r=0;r<e;r++)o[r]=-o[r];j(t,o);for(let r=0;r<e;r++)t[r]/=e,o[r]=-o[r]/e}function ft(t={}){const{dims:o=[128,128,32],gridSize:e=64,octaves:r=6,amplitude:l=.1}=t,[f,i,a]=o;console.time("3D Volume Generation");const n=f*i*a,s=new Float32Array(n),c=.5;let d=0;for(let m=0;m<a;m++)for(let u=0;u<i;u++)for(let p=0;p<f;p++){const w=p/f,y=u/i,M=m/a,A=tt(w,y,M,e,r,c)*l,v=Math.max(0,Math.min(255,(A+1)*127.5));s[d++]=v}return console.timeEnd("3D Volume Generation"),console.log(`Generated 3D volume: ${f}x${i}x${a} = ${n} voxels`),s.d1=f,s.d2=i,s.d3=a,s}function it(t,o,e={}){const{method:r=0,windowSize:l=7,scales:f=[1,2,3],backend:i="webgl",...a}=e;switch(r){case 0:return et(t,o,{windowSize:l,scales:f,backend:i,...a});case 1:return Y(t,o,{windowSize:l,scales:f,...a});default:throw new Error(`Unsupported method: ${r}. Use 0 for TensorFlow or 1 for CPU.`)}}function Y(t,o,e={}){const{windowSize:r=7,scales:l=[1,2,3]}=e,[f,i,a]=o,n=Math.floor(r/2),s=f*i,c=f*i*a,d=new Float32Array(c),m=[],u=[];m[0]=new Float32Array(t),u[0]=new Float32Array(t);for(let p=1;p<=l[l.length-1];p++){m[p]=new Float32Array(c),u[p]=new Float32Array(c);for(let w=0;w<a;w++)for(let y=0;y<i;y++)for(let M=0;M<f;M++){const h=w*s+y*f+M;let A=m[p-1][h]+1,v=u[p-1][h]-1;for(let z=-1;z<=1;z++)for(let b=-1;b<=1;b++)for(let F=-1;F<=1;F++){const x=Math.min(Math.max(w+z,0),a-1),g=Math.min(Math.max(y+b,0),i-1),k=Math.min(Math.max(M+F,0),f-1),B=x*s+g*f+k;A=Math.max(A,m[p-1][B]),v=Math.min(v,u[p-1][B])}m[p][h]=A,u[p][h]=v}}for(let p=0;p<a;p++)for(let w=0;w<i;w++)for(let y=0;y<f;y++){const M=[],h=[];for(let b of l){let F=0;for(let x=-n;x<=n;x++)for(let g=-n;g<=n;g++)for(let k=-n;k<=n;k++){const B=Math.min(Math.max(p+x,0),a-1),I=Math.min(Math.max(w+g,0),i-1),T=Math.min(Math.max(y+k,0),f-1),D=B*s+I*f+T;F+=m[b][D]-u[b][D]}F>0&&(M.push(Math.log(F)),h.push(Math.log(b)))}const{slope:A}=q(h,M),v=4-A,z=p*s+w*f+y;d[z]=Math.min(4,Math.max(3,v))}return d}function et(t,o,e={}){const{windowSize:r=7,scales:l=[1,2,3],backend:f="webgl"}=e,[i,a,n]=o,s=tf.getBackend();tf.setBackend(f),console.log(`fd3dtf using TensorFlow.js backend: ${tf.getBackend()}`);try{return tf.tidy(()=>{const c=tf.tensor3d(t,[n,a,i],"float32"),d=Math.max(...l,0),m=[],u=[];m[0]=c.clone(),u[0]=c.clone();for(let x=1;x<=d;x++){const g=m[x-1],k=u[x-1],B=tf.pad(g,[[1,1],[1,1],[1,1]],"symmetric"),I=tf.maxPool3d(B.expandDims(0).expandDims(-1),[3,3,3],1,"valid").squeeze([0,-1]);m[x]=tf.maximum(g.add(1),I);const T=tf.pad(k,[[1,1],[1,1],[1,1]],"symmetric"),D=tf.neg(tf.maxPool3d(tf.neg(T.expandDims(0).expandDims(-1)),[3,3,3],1,"valid")).squeeze([0,-1]);u[x]=tf.minimum(k.sub(1),D)}const p=tf.log(tf.tensor1d(l,"float32")),w=[],y=tf.ones([r,r,r,1,1],"float32");for(const x of l){const g=m[x],k=u[x];if(!g||!k){console.warn(`Blankets for scale ${x} not found or already disposed. Skipping.`);continue}const I=tf.sub(g,k).expandDims(0).expandDims(-1),T=tf.conv3d(I,y,1,"same").squeeze([0,4]);w.push(tf.log(tf.maximum(T,1e-7)))}const M=tf.stack(w),h=p.reshape([l.length,1,1,1]),A=tf.tile(h,[1,n,a,i]),v=st(A,M),F=tf.sub(4,v).clipByValue(3,4).dataSync();for(let x=0;x<=d;x++)l.includes(x)||(m[x]&&m[x]!==c&&!m[x].isDisposed&&m[x].dispose(),u[x]&&u[x]!==c&&!u[x].isDisposed&&u[x].dispose());return new Float32Array(F)})}catch(c){return console.error("Error in fd3dtf:",c),console.warn("Falling back to CPU implementation"),s&&s!==tf.getBackend()&&tf.setBackend(s),Y(t,o,e)}finally{s&&s!==tf.getBackend()&&tf.setBackend(s)}}function nt(t,o){return tf.tidy(()=>{const e=tf.scalar(t.shape[0],"float32"),r=tf.sum(t,0),l=tf.sum(o,0),f=tf.sum(tf.mul(t,o),0),i=tf.sum(tf.square(t),0),a=tf.sub(tf.mul(e,f),tf.mul(r,l)),n=tf.sub(tf.mul(e,i),tf.square(r)),s=1e-6,c=tf.where(tf.abs(n).lessEqual(s),tf.onesLike(n).mul(s),n);return tf.div(a,c)})}function st(t,o){return tf.tidy(()=>{const e=tf.scalar(t.shape[0],"float32"),r=tf.sum(t,0),l=tf.sum(o,0),f=tf.sum(tf.mul(t,o),0),i=tf.sum(tf.square(t),0),a=tf.sub(tf.mul(e,f),tf.mul(r,l)),n=tf.sub(tf.mul(e,i),tf.square(r)),s=tf.scalar(1e-10,"float32"),c=tf.maximum(tf.abs(n),s);return tf.div(a,c)})}async function at(t,o,e,r,l,f={}){f={windowSize:7,scales:[1,2,3],method:0,...f};const{windowSize:i,scales:a,method:n}=f;let s;if(t instanceof Float32Array)s=t;else if(ArrayBuffer.isView(t))s=new Float32Array(t);else if(Array.isArray(t))s=new Float32Array(t);else throw new Error("Input slice must be a Float32Array, TypedArray, or Array");return X(s,r,l,f)}async function _(t,o={}){if(!t||!t.data||!t.size||!Array.isArray(t.size))throw new Error("Invalid image object provided to calcfd");const[e,r,l]=t.size,f=t.data,i=e*r,a={imageType:{dimension:t.imageType.dimension,componentType:"float32",pixelType:t.imageType.pixelType,components:t.imageType.components},name:"FractalDimensionImage",origin:[...t.origin],spacing:[...t.spacing],direction:new Float64Array(t.direction),size:[e,r,l],data:new Float32Array(i*l)};for(let n=0;n<l;n++){const s=n*i,c=f.subarray(s,s+i),d=n*i;try{const m=await at(c,a,d,e,r,o);m&&m.length===i?a.data.set(m,d):m?console.warn(`Slice ${n}: Unexpected result format from computefd2d`):console.log(`Slice ${n}: Using direct buffer modification (TF/GPU method)`)}catch(m){console.error(`Error processing slice ${n}:`,m);const u=new Float32Array(i).fill(NaN);a.data.set(u,d)}}return a}async function mt(t,o={}){try{const{resolution:e}=o;if(t.size.length===3){const r=await P(t,e),l=await _(r,o);return{resampledImage:r,fdImage:l}}else if(t.size.length===4){const[r,l,f,i]=t.size,a=r*l*f,n=R(t,0,a),s=await P(n,e),c=await _(s,o),[d,m,u]=s.size,p=d*m*u,w=N(t,s,i,p),y=N(t,c,i,p);w.data.set(s.data,0),y.data.set(c.data,0);for(let M=1;M<i;M++){const h=R(t,M,a),A=await P(h,e),v=await _(A,o),z=M*p;w.data.set(A.data,z),y.data.set(v.data,z)}return{resampledImage:w,fdImage:y}}else throw new Error(`Unsupported number of dimensions: ${t.size.length}. Only 3D and 4D volumes are supported.`)}catch(e){throw console.error("Error in resampleandfd:",e),e}}function R(t,o,e){const[r,l,f]=t.size,i=o*e,a=t.data.subarray(i,i+e);return{imageType:{dimension:3,componentType:t.imageType.componentType,pixelType:t.imageType.pixelType,components:t.imageType.components},name:`Volume_t${o}`,origin:t.origin.slice(0,3),spacing:t.spacing.slice(0,3),direction:new Float64Array(t.direction.slice(0,9)),size:[r,l,f],data:a}}function N(t,o,e,r){const[l,f,i]=o.size,a=r*e;return{imageType:{dimension:4,componentType:o.imageType.componentType,pixelType:o.imageType.pixelType,components:o.imageType.components},name:o.name+"_4D",origin:[...t.origin],spacing:[...o.spacing,t.spacing[3]],direction:new Float64Array(t.direction),size:[l,f,i,e],data:new Float32Array(a)}}export{it as a,lt as f,ft as g,mt as r};
