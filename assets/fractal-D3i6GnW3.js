import{a as G}from"./index-CVwNq2Ey.js";function C(t,o,n,l,r,f,i="clamp",a="nearest"){const e=r>1?o/r:o/2,s=f>1?n/f:n/2,c=a==="nearest"||a==="nearestNeighbor";for(let m=0;m<f;m++)for(let d=0;d<r;d++){const p=(d+.5)*e-.5,u=(m+.5)*s-.5;let w;if(c){const y=Math.round(p),A=Math.round(u);w=E(t,y,A,o,n,i)}else{const y=Math.floor(p),A=Math.floor(u),h=E(t,y,A,o,n,i),x=E(t,y+1,A,o,n,i),g=E(t,y,A+1,o,n,i),z=E(t,y+1,A+1,o,n,i),v=p-y,F=u-A;w=(1-v)*(1-F)*h+v*(1-F)*x+(1-v)*F*g+v*F*z}l[d+m*r]=w}}function E(t,o,n,l,r,f){if(o>=0&&o<l&&n>=0&&n<r)return t[o+n*l];let i=o,a=n;switch(f){case"clamp":i=Math.max(0,Math.min(l-1,o)),a=Math.max(0,Math.min(r-1,n));break;case"mirror":o<0?i=-o-1:o>=l&&(i=2*l-o-1),n<0?a=-n-1:n>=r&&(a=2*r-n-1),i=Math.max(0,Math.min(l-1,i)),a=Math.max(0,Math.min(r-1,a));break;case"wrap":i=(o%l+l)%l,a=(n%r+r)%r;break;case"zero":return 0;default:i=Math.max(0,Math.min(l-1,o)),a=Math.max(0,Math.min(r-1,n))}return t[i+a*l]}async function P(t,o){if(o<=0)throw new Error("Resolution must be positive");const[n,l,r]=t.size,f=t.spacing,i=t.data,a=Math.max(1,Math.round(n*f[0]/o)),e=Math.max(1,Math.round(l*f[1]/o)),s=n*l,c=a*e,m={imageType:{dimension:t.imageType.dimension,componentType:"float32",pixelType:t.imageType.pixelType,components:t.imageType.components},name:"ResampledImage",origin:[...t.origin],spacing:[o,o,f[2]],direction:new Float64Array(t.direction),size:[a,e,r],data:new Float32Array(c*r)},d=new Float32Array(c);for(let p=0;p<r;p++){const u=p*s,w=i.subarray(u,u+s),y=p*c;d.fill(0),C(w,n,l,d,a,e),m.data.set(d,y)}return m}async function $(t,o,n,l={}){const{windowSize:r=7,scales:f=[1,2,3],method:i=0,backend:a="webgl"}=l;performance.now();let e;switch(i){case 1:e=await J(t,o,n,l);break;case 2:e=await Q(t,o,n,l);break;case 0:default:e=await K(t,o,n,l);break}return performance.now(),e}async function K(t,o,n,l={}){await G();const{windowSize:r=7,scales:f=[1,2,3],backend:i="webgl"}=l;return tf.setBackend(i),tf.tidy(()=>{const a=tf.tensor2d(t,[n,o],"float32");if(a.rank!==2)throw new Error("Input image must be 2D.");const e=a.expandDims(0).expandDims(-1),s=f[f.length-1],c=tf.log(tf.tensor1d(f,"float32")),m={},d={};let p=e.clone(),u=e.clone();m[0]=p.clone(),d[0]=u.clone(),tf.ones([3,3,1],"bool");const w=3,y=1,A="valid",h=[[0,0],[1,1],[1,1],[0,0]];for(let T=1;T<=s;T++){const D=p,S=u;p=tf.tidy(()=>{const L=tf.pad(D,h,"reflect"),U=tf.maxPool(L,w,y,A);return tf.maximum(tf.add(D,1),U)}),u=tf.tidy(()=>{const L=S.neg(),U=tf.pad(L,h,"reflect"),O=tf.maxPool(U,w,y,A).neg();return tf.minimum(tf.sub(S,1),O)}),tf.dispose([D,S]),f.includes(T)&&(m[T]=p.clone(),d[T]=u.clone())}f.includes(s)||tf.dispose([p,u]);const x=[],g=tf.scalar(r*r,"float32"),z=tf.scalar(1e-6);for(const T of f){const D=tf.sub(m[T],d[T]),S=tf.avgPool(D,r,1,"same"),L=tf.mul(S,g),U=tf.maximum(L.squeeze([0,3]),z);x.push(tf.log(U)),tf.dispose([D,S,L,U,m[T],d[T]])}tf.dispose([m[0],d[0]]);const v=tf.stack(x,0),F=c.reshape([-1,1,1]),M=tf.tile(F,[1,n,o]),b=nt(M,v),k=tf.sub(3,b),B=k.clipByValue(2,3);tf.dispose(x),tf.dispose([v,F,M,b,k]);const I=B.dataSync();return tf.dispose([a,B,...Object.values(m),...Object.values(d)].filter(Boolean)),new Float32Array(I)})}async function lt(t,o,n,l,r,f,i,a){const s=2*(3-t)+2,c=Z(o,o,s),m=await $(c,o,o,{windowSize:n,scales:r,method:i}),d=await $(c,o,o,{windowSize:l,scales:f,method:a});return{originalImage:c,fractalDimension1:m,fractalDimension2:d,parameters:{dimension:t,size:o,window1:n,window2:l,scales1:r,scales2:f,method1:i,method2:a}}}async function J(t,o,n,l={}){const{windowSize:r=7,scales:f=[1,2,3]}=l,i=Math.floor(r/2),a=new Float32Array(o*n),e=[],s=[];e[0]=new Float32Array(t),s[0]=new Float32Array(t);for(let c=1;c<=f[f.length-1];c++){e[c]=new Float32Array(o*n),s[c]=new Float32Array(o*n);for(let m=0;m<n;m++)for(let d=0;d<o;d++){const p=m*o+d;let u=e[c-1][p]+1,w=s[c-1][p]-1;for(let y=-1;y<=1;y++)for(let A=-1;A<=1;A++){const h=Math.min(Math.max(m+y,0),n-1),x=Math.min(Math.max(d+A,0),o-1),g=h*o+x;u=Math.max(u,e[c-1][g]),w=Math.min(w,s[c-1][g])}e[c][p]=u,s[c][p]=w}}for(let c=0;c<n;c++)for(let m=0;m<o;m++){const d=[],p=[];for(let A of f){let h=0;for(let x=-i;x<=i;x++)for(let g=-i;g<=i;g++){const z=Math.min(Math.max(c+x,0),n-1),v=Math.min(Math.max(m+g,0),o-1),F=z*o+v;h+=e[A][F]-s[A][F]}h>0&&(d.push(Math.log(h)),p.push(Math.log(A)))}const{slope:u}=j(p,d),w=3-u,y=c*o+m;a[y]=Math.min(3,Math.max(2,w))}return a}function j(t,o){if(!Array.isArray(t)||!Array.isArray(o)||t.length!==o.length||t.length===0)return{slope:0,intercept:0};const n=t.length;let l=0,r=0,f=0,i=0;for(let c=0;c<n;c++){if(typeof t[c]!="number"||typeof o[c]!="number"||!isFinite(t[c])||!isFinite(o[c]))return{slope:0,intercept:0};l+=t[c],r+=o[c],f+=t[c]*o[c],i+=t[c]*t[c]}const a=n*i-l*l;if(a===0)return{slope:0,intercept:r/n};const e=(n*f-l*r)/a,s=(r-e*l)/n;return{slope:e,intercept:s}}async function Q(t,o,n,l={}){const{windowSize:r=7,scales:f=[1,2,3]}=l,i=new Float32Array(o*n),a=Math.floor(r/2);for(let e=0;e<n;e++)for(let s=0;s<o;s++){const c=new Float32Array(r*r);for(let x=0;x<r;x++)for(let g=0;g<r;g++){const z=e+x-a,v=s+g-a,F=Math.max(0,Math.min(n-1,z)),M=Math.max(0,Math.min(o-1,v));c[x*r+g]=t[F*o+M]}let m=new Float32Array(c),d=new Float32Array(c);const p=[],u=Math.max(...f);for(let x=1;x<=u;x++){const g=m,z=d;m=new Float32Array(r*r),d=new Float32Array(r*r);for(let v=0;v<r;v++)for(let F=0;F<r;F++){const M=v*r+F;let b=g[M]+1,k=z[M]-1;for(let B=-1;B<=1;B++)for(let I=-1;I<=1;I++){const T=v+B,D=F+I;if(T>=0&&T<r&&D>=0&&D<r){const S=T*r+D;b=Math.max(b,g[S]),k=Math.min(k,z[S])}}m[M]=b,d[M]=k}if(f.includes(x)){let v=0;for(let F=0;F<m.length;F++)v+=m[F]-d[F];p.push(v>0?v:1e-9)}}if(p.length!==f.length){i[e*o+s]=2;continue}const w=p.map(x=>Math.log(x)),y=f.map(x=>Math.log(x));if(y.length<2){i[e*o+s]=2;continue}const{slope:A}=j(y,w),h=3-A;i[e*o+s]=Math.min(3,Math.max(2,h))}return i}function Z(t,o,n){console.time("fBm Generation");const l=new Float32Array(t*o),r=new Float32Array(t*o);for(let s=0;s<o;s++)for(let c=0;c<t;c++){const m=c<t/2?c:c-t,d=s<o/2?s:s-o,p=Math.sqrt(m*m+d*d),u=s*t+c;if(p===0)l[u]=0,r[u]=0;else{const w=Math.pow(p,-n/2),y=Math.random()*2*Math.PI;l[u]=w*Math.cos(y),r[u]=w*Math.sin(y)}}W(l,r,!0,t,o);const f=new Float32Array(t*o);for(let s=0;s<t*o;s++)f[s]=l[s];let i=1/0,a=-1/0;for(let s=0;s<f.length;s++)f[s]<i&&(i=f[s]),f[s]>a&&(a=f[s]);const e=new Uint8ClampedArray(t*o);for(let s=0;s<f.length;s++)e[s]=Math.round((f[s]-i)/(a-i)*255);return console.timeEnd("fBm Generation"),e}function W(t,o,n=!1,l,r){for(let a=0;a<r;a++){const e=new Float32Array(l),s=new Float32Array(l);for(let c=0;c<l;c++){const m=a*l+c;e[c]=t[m],s[c]=o[m]}n?q(e,s):X(e,s);for(let c=0;c<l;c++){const m=a*l+c;t[m]=e[c],o[m]=s[c]}}const f=new Float32Array(l*r),i=new Float32Array(l*r);for(let a=0;a<r;a++)for(let e=0;e<l;e++)f[e*r+a]=t[a*l+e],i[e*r+a]=o[a*l+e];for(let a=0;a<l;a++){const e=new Float32Array(r),s=new Float32Array(r);for(let c=0;c<r;c++){const m=a*r+c;e[c]=f[m],s[c]=i[m]}n?q(e,s):X(e,s);for(let c=0;c<r;c++){const m=a*r+c;f[m]=e[c],i[m]=s[c]}}for(let a=0;a<r;a++)for(let e=0;e<l;e++)t[a*l+e]=f[e*r+a],o[a*l+e]=i[e*r+a]}function V(t,o,n){return(t*73856093^o*19349663^n*83492791)%1e6/1e6}function H(t,o,n){const l=Math.floor(t),r=Math.floor(o),f=Math.floor(n),i=l+1,a=r+1,e=f+1,s=t-l,c=o-r,m=n-f,d=V(l,r,f),p=V(i,r,f),u=V(l,a,f),w=V(i,a,f),y=V(l,r,e),A=V(i,r,e),h=V(l,a,e),x=V(i,a,e),g=d*(1-s)+p*s,z=u*(1-s)+w*s,v=y*(1-s)+A*s,F=h*(1-s)+x*s,M=g*(1-c)+z*c,b=v*(1-c)+F*c;return M*(1-m)+b*m}function tt(t,o,n,l,r,f){let i=0,a=1,e=1;for(let s=0;s<r;s++)i+=a*H(t*e*l,o*e*l,n*e*l),a*=f,e*=2;return i}function ot(t,o){const n=t.length;if(n!==o.length||(n&n-1)!==0)throw new Error("Invalid array length: must be power of 2");let l=-1;for(let e=0;e<32;e++)1<<e===n&&(l=e);if(l===-1)throw new Error("Length is not a power of 2");const r=new Float32Array(n/2),f=new Float32Array(n/2);for(let e=0;e<n/2;e++)r[e]=Math.cos(2*Math.PI*e/n),f[e]=Math.sin(2*Math.PI*e/n);function i(e,s){let c=0;for(let m=0;m<s;m++)c=c<<1|e&1,e>>>=1;return c}const a=n;for(let e=0;e<a;e++){const s=i(e,l);if(s>e){const c=t[e];t[e]=t[s],t[s]=c;const m=o[e];o[e]=o[s],o[s]=m}}for(let e=2;e<=n;e*=2){const s=e/2,c=n/e;for(let m=0;m<n;m+=e)for(let d=m,p=0;d<m+s;d++,p+=c){const u=t[d+s]*r[p]+o[d+s]*f[p],w=-t[d+s]*f[p]+o[d+s]*r[p];t[d+s]=t[d]-u,o[d+s]=o[d]-w,t[d]+=u,o[d]+=w}}}function X(t,o){const n=t.length;if(n!==o.length)throw new Error("Mismatched lengths");if((n&n-1)===0)ot(t,o);else{const l=new Float32Array(n*n),r=new Float32Array(n*n);for(let a=0;a<n;a++)for(let e=0;e<n;e++){const s=-2*Math.PI*(a*e%n)/n;l[a*n+e]=Math.cos(s),r[a*n+e]=Math.sin(s)}const f=new Float32Array(n),i=new Float32Array(n);for(let a=0;a<n;a++){let e=0,s=0;for(let c=0;c<n;c++)e+=t[c]*l[c*n+a]+o[c]*r[c*n+a],s+=-t[c]*r[c*n+a]+o[c]*l[c*n+a];f[a]=e,i[a]=s}for(let a=0;a<n;a++)t[a]=f[a],o[a]=i[a]}}function q(t,o){const n=t.length;for(let l=0;l<n;l++)o[l]=-o[l];X(t,o);for(let l=0;l<n;l++)t[l]/=n,o[l]=-o[l]/n}function ft(t={}){const{dims:o=[128,128,32],gridSize:n=64,octaves:l=6,amplitude:r=.1}=t,[f,i,a]=o;console.time("3D Volume Generation");const e=f*i*a,s=new Float32Array(e),c=.5;let m=0;for(let d=0;d<a;d++)for(let p=0;p<i;p++)for(let u=0;u<f;u++){const w=u/f,y=p/i,A=d/a,x=tt(w,y,A,n,l,c)*r,g=Math.max(0,Math.min(255,(x+1)*127.5));s[m++]=g}return console.timeEnd("3D Volume Generation"),console.log(`Generated 3D volume: ${f}x${i}x${a} = ${e} voxels`),s.d1=f,s.d2=i,s.d3=a,s}function it(t,o,n={}){const{method:l=0,windowSize:r=7,scales:f=[1,2,3],backend:i="webgl",...a}=n;switch(l){case 0:return et(t,o,{windowSize:r,scales:f,backend:i,...a});case 1:return Y(t,o,{windowSize:r,scales:f,...a});default:throw new Error(`Unsupported method: ${l}. Use 0 for TensorFlow or 1 for CPU.`)}}function Y(t,o,n={}){const{windowSize:l=7,scales:r=[1,2,3]}=n,[f,i,a]=o,e=Math.floor(l/2),s=f*i,c=f*i*a,m=new Float32Array(c),d=[],p=[];d[0]=new Float32Array(t),p[0]=new Float32Array(t);for(let u=1;u<=r[r.length-1];u++){d[u]=new Float32Array(c),p[u]=new Float32Array(c);for(let w=0;w<a;w++)for(let y=0;y<i;y++)for(let A=0;A<f;A++){const h=w*s+y*f+A;let x=d[u-1][h]+1,g=p[u-1][h]-1;for(let z=-1;z<=1;z++)for(let v=-1;v<=1;v++)for(let F=-1;F<=1;F++){const M=Math.min(Math.max(w+z,0),a-1),b=Math.min(Math.max(y+v,0),i-1),k=Math.min(Math.max(A+F,0),f-1),B=M*s+b*f+k;x=Math.max(x,d[u-1][B]),g=Math.min(g,p[u-1][B])}d[u][h]=x,p[u][h]=g}}for(let u=0;u<a;u++)for(let w=0;w<i;w++)for(let y=0;y<f;y++){const A=[],h=[];for(let v of r){let F=0;for(let M=-e;M<=e;M++)for(let b=-e;b<=e;b++)for(let k=-e;k<=e;k++){const B=Math.min(Math.max(u+M,0),a-1),I=Math.min(Math.max(w+b,0),i-1),T=Math.min(Math.max(y+k,0),f-1),D=B*s+I*f+T;F+=d[v][D]-p[v][D]}F>0&&(A.push(Math.log(F)),h.push(Math.log(v)))}const{slope:x}=j(h,A),g=4-x,z=u*s+w*f+y;m[z]=Math.min(4,Math.max(3,g))}return m}function et(t,o,n={}){const{windowSize:l=7,scales:r=[1,2,3],backend:f="webgl"}=n,[i,a,e]=o,s=tf.getBackend();tf.setBackend(f),console.log(`fd3dtf using TensorFlow.js backend: ${tf.getBackend()}`);try{return tf.tidy(()=>{const c=tf.tensor3d(t,[e,a,i],"float32"),m=Math.max(...r,0),d=[],p=[];d[0]=c.clone(),p[0]=c.clone();for(let M=1;M<=m;M++){const b=d[M-1],k=p[M-1],B=tf.pad(b,[[1,1],[1,1],[1,1]],"symmetric"),I=tf.maxPool3d(B.expandDims(0).expandDims(-1),[3,3,3],1,"valid").squeeze([0,-1]);d[M]=tf.maximum(b.add(1),I);const T=tf.pad(k,[[1,1],[1,1],[1,1]],"symmetric"),D=tf.neg(tf.maxPool3d(tf.neg(T.expandDims(0).expandDims(-1)),[3,3,3],1,"valid")).squeeze([0,-1]);p[M]=tf.minimum(k.sub(1),D)}const u=tf.log(tf.tensor1d(r,"float32")),w=[],y=tf.ones([l,l,l,1,1],"float32");for(const M of r){const b=d[M],k=p[M];if(!b||!k){console.warn(`Blankets for scale ${M} not found or already disposed. Skipping.`);continue}const I=tf.sub(b,k).expandDims(0).expandDims(-1),T=tf.conv3d(I,y,1,"same").squeeze([0,4]);w.push(tf.log(tf.maximum(T,1e-7)))}const A=tf.stack(w),h=u.reshape([r.length,1,1,1]),x=tf.tile(h,[1,e,a,i]),g=st(x,A),F=tf.sub(4,g).clipByValue(3,4).dataSync();for(let M=0;M<=m;M++)r.includes(M)||(d[M]&&d[M]!==c&&!d[M].isDisposed&&d[M].dispose(),p[M]&&p[M]!==c&&!p[M].isDisposed&&p[M].dispose());return new Float32Array(F)})}catch(c){return console.error("Error in fd3dtf:",c),console.warn("Falling back to CPU implementation"),s&&s!==tf.getBackend()&&tf.setBackend(s),Y(t,o,n)}finally{s&&s!==tf.getBackend()&&tf.setBackend(s)}}function nt(t,o){return tf.tidy(()=>{const n=tf.scalar(t.shape[0],"float32"),l=tf.sum(t,0),r=tf.sum(o,0),f=tf.sum(tf.mul(t,o),0),i=tf.sum(tf.square(t),0),a=tf.sub(tf.mul(n,f),tf.mul(l,r)),e=tf.sub(tf.mul(n,i),tf.square(l)),s=1e-6,c=tf.where(tf.abs(e).lessEqual(s),tf.onesLike(e).mul(s),e);return tf.div(a,c)})}function st(t,o){return tf.tidy(()=>{const n=tf.scalar(t.shape[0],"float32"),l=tf.sum(t,0),r=tf.sum(o,0),f=tf.sum(tf.mul(t,o),0),i=tf.sum(tf.square(t),0),a=tf.sub(tf.mul(n,f),tf.mul(l,r)),e=tf.sub(tf.mul(n,i),tf.square(l)),s=tf.scalar(1e-10,"float32"),c=tf.maximum(tf.abs(e),s);return tf.div(a,c)})}async function at(t,o,n,l,r,f={}){f={windowSize:7,scales:[1,2,3],method:0,...f};const{windowSize:i,scales:a,method:e}=f;let s;if(t instanceof Float32Array)s=t;else if(ArrayBuffer.isView(t))s=new Float32Array(t);else if(Array.isArray(t))s=new Float32Array(t);else throw new Error("Input slice must be a Float32Array, TypedArray, or Array");return $(s,l,r,f)}async function _(t,o={}){if(!t||!t.data||!t.size||!Array.isArray(t.size))throw new Error("Invalid image object provided to calcfd");const[n,l,r]=t.size,f=t.data,i=n*l,a={imageType:{dimension:t.imageType.dimension,componentType:"float32",pixelType:t.imageType.pixelType,components:t.imageType.components},name:"FractalDimensionImage",origin:[...t.origin],spacing:[...t.spacing],direction:new Float64Array(t.direction),size:[n,l,r],data:new Float32Array(i*r)};for(let e=0;e<r;e++){const s=e*i,c=f.subarray(s,s+i),m=e*i;try{const d=await at(c,a,m,n,l,o);d&&d.length===i?a.data.set(d,m):d?console.warn(`Slice ${e}: Unexpected result format from computefd2d`):console.log(`Slice ${e}: Using direct buffer modification (TF/GPU method)`)}catch(d){console.error(`Error processing slice ${e}:`,d);const p=new Float32Array(i).fill(NaN);a.data.set(p,m)}}return a}async function mt(t,o={}){const n=performance.now(),l=t.size.length;try{console.log(`[resampleandfd] Starting processing ${l}D volume`);const{resolution:r}=o;if(t.size.length===3){const f=await P(t,r),i=await _(f,o);return{resampledImage:f,fdImage:i}}else if(t.size.length===4){const[f,i,a,e]=t.size,s=f*i*a,c=R(t,0,s),m=await P(c,r),d=await _(m,o),[p,u,w]=m.size,y=p*u*w,A=N(t,m,e,y),h=N(t,d,e,y);A.data.set(m.data,0),h.data.set(d.data,0);for(let x=1;x<e;x++){const g=R(t,x,s),z=await P(g,r),v=await _(z,o),F=x*y;A.data.set(z.data,F),h.data.set(v.data,F)}return{resampledImage:A,fdImage:h}}else throw new Error(`Unsupported number of dimensions: ${t.size.length}. Only 3D and 4D volumes are supported.`)}catch(r){throw console.error("Error in resampleandfd:",r),r}finally{const r=performance.now();console.log(`[resampleandfd] Completed processing ${l}D volume in ${(r-n).toFixed(2)}ms`)}}function R(t,o,n){const[l,r,f]=t.size,i=o*n,a=t.data.subarray(i,i+n);return{imageType:{dimension:3,componentType:t.imageType.componentType,pixelType:t.imageType.pixelType,components:t.imageType.components},name:`Volume_t${o}`,origin:t.origin.slice(0,3),spacing:t.spacing.slice(0,3),direction:new Float64Array(t.direction.slice(0,9)),size:[l,r,f],data:a}}function N(t,o,n,l){const[r,f,i]=o.size,a=l*n;return{imageType:{dimension:4,componentType:o.imageType.componentType,pixelType:o.imageType.pixelType,components:o.imageType.components},name:o.name+"_4D",origin:[...t.origin],spacing:[...o.spacing,t.spacing[3]],direction:new Float64Array(t.direction),size:[r,f,i,n],data:new Float32Array(a)}}export{it as a,lt as f,ft as g,mt as r};
